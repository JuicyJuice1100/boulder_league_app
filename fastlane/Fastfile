# Fastfile for Boulder League App - Android Only
# Firebase App Distribution

default_platform(:android)

platform :android do
  desc "Bump version based on current git branch"
  lane :bump do
    bump_version()
  end

  desc "Build Android APK only (auto-bumps version)"
  lane :build do |options|
    # Load environment
    env = options[:env] || "dev"
    load_env(env)

    # Auto-bump version
    version = bump_version()
    version_string = "#{version[:name]}+#{version[:code]}"

    # Build APK
    build_apk()

    puts "✅ Build complete!"
    puts "📦 Version: #{version_string}"
    puts "🌍 Environment: #{env}"
    puts "📦 Location: build/app/outputs/flutter-apk/app-release.apk"
  end

  desc "Build and deploy Android app to Firebase App Distribution (auto-bumps version)"
  desc "Usage: fastlane android build_and_deploy env:dev|uat|prod"
  lane :build_and_deploy do |options|
    # Load environment (default to dev)
    env = options[:env] || "dev"
    load_env(env)

    # Auto-bump version
    version = bump_version()
    version_string = "#{version[:name]}+#{version[:code]}"

    # Build APK
    build_apk()

    # Deploy to Firebase
    deploy_to_firebase(version, options, env)

    puts "✅ Build and deployment complete!"
    puts "📦 Version: #{version_string}"
    puts "🌍 Environment: #{env}"
  end

  # Helper methods for lanes
  def build_apk
    puts "🔨 Building Android APK..."
    gradle(
      task: "clean assembleRelease",
      project_dir: "android/"
    )
    puts "✅ APK built successfully!"
  end

  def deploy_to_firebase(version, options = {}, env = "dev")
    # version is a hash with :name and :code
    version_name = version[:name]
    version_code = version[:code]
    version_string = "#{version_name}+#{version_code}"

    # Get parameters
    release_notes = options[:release_notes] || "Version #{version_name} (Build #{version_code}) - New build from Fastlane"
    groups = options[:groups] || "testers"

    # Get debug mode from environment variable
    debug_mode = ENV["DEBUG"] == "true"

    puts "🚀 Deploying to Firebase App Distribution..."
    puts "   Version: #{version_string}"
    puts "   Environment: #{env}"
    puts "   Release Number: #{version_name}"
    puts "   Build Number: #{version_code}"
    puts "   Debug Mode: #{debug_mode}"

    # Upload to Firebase App Distribution
    firebase_app_distribution(
      app: get_firebase_android_app_id(),
      firebase_cli_token: get_firebase_token(),
      groups: groups,
      release_notes: release_notes,
      release_notes_file: nil,
      apk_path: "build/app/outputs/flutter-apk/app-release.apk",
      android_artifact_type: "APK",
      android_artifact_path: "build/app/outputs/flutter-apk/app-release.apk",
      service_credentials_file: nil,
      debug: debug_mode
    )

    puts "✅ Deployed to Firebase App Distribution!"
    puts "   Release: #{version_name}"
    puts "   Build: #{version_code}"
    puts "   Environment: #{env}"
  end

  def bump_version
    current_version = get_version()
    branch_name = get_git_branch()

    current_version_string = "#{current_version[:name]}+#{current_version[:code]}"
    puts "📌 Current version: #{current_version_string}"
    puts "   versionName: #{current_version[:name]}"
    puts "   versionCode: #{current_version[:code]}"
    puts "🌿 Current branch: #{branch_name}"

    new_version = calculate_new_version(current_version, branch_name)
    new_version_string = "#{new_version[:name]}+#{new_version[:code]}"

    puts "⬆️  Bumping version:"
    puts "   #{current_version[:name]} -> #{new_version[:name]} (versionName)"
    puts "   #{current_version[:code]} -> #{new_version[:code]} (versionCode)"

    # Update pubspec.yaml
    pubspec_path = File.join(Dir.pwd, "..", "pubspec.yaml")
    pubspec_content = File.read(pubspec_path)

    # Replace the version line
    updated_content = pubspec_content.gsub(
      /^version:\s*\d+\.\d+\.\d+\+\d+/,
      "version: #{new_version_string}"
    )

    File.write(pubspec_path, updated_content)

    # Update local.properties
    local_properties_path = File.join(Dir.pwd, "..", "android", "local.properties")

    if !File.exist?(local_properties_path)
      UI.user_error!(
        "❌ local.properties not found at: #{local_properties_path}\n" +
        "   Please run 'flutter build apk' or 'flutter run' first to generate this file."
      )
    end

    local_properties_content = File.read(local_properties_path)

    # Update flutter.versionName
    updated_local_properties = local_properties_content.gsub(
      /^flutter\.versionName=.*/,
      "flutter.versionName=#{new_version[:name]}"
    )

    # Update flutter.versionCode
    updated_local_properties = updated_local_properties.gsub(
      /^flutter\.versionCode=.*/,
      "flutter.versionCode=#{new_version[:code]}"
    )

    File.write(local_properties_path, updated_local_properties)

    puts "✅ Version bumped to #{new_version_string}"
    puts "   Updated in pubspec.yaml"
    puts "   Updated in android/local.properties"

    new_version
  end
end

# Helper methods
def get_firebase_token
  token = ENV["FIREBASE_TOKEN"]

  if token.nil? || token.empty?
    UI.user_error!(
      "❌ Firebase token not found in environment variables.\n" +
      "   Please ensure FIREBASE_TOKEN is set in your .env file.\n" +
      "   Run 'firebase login:ci' to get your token."
    )
  end

  token
end

def get_firebase_android_app_id
  app_id = ENV["FIREBASE_ANDROID_APP_ID"]

  if app_id.nil? || app_id.empty?
    UI.user_error!(
      "❌ Firebase Android App ID not found in environment variables.\n" +
      "   Please ensure FIREBASE_ANDROID_APP_ID is set in your .env file.\n" +
      "   Find this in Firebase Console > Project Settings > General > Your apps"
    )
  end

  app_id
end

def get_version
  pubspec_path = File.join(Dir.pwd, "..", "pubspec.yaml")
  if File.exist?(pubspec_path)
    pubspec_content = File.read(pubspec_path)
    # Match version in format: version: 1.0.0+1
    if pubspec_content =~ /^version:\s*(\d+\.\d+\.\d+)\+(\d+)/
      version_name = $1
      version_code = $2
      return { name: version_name, code: version_code.to_i }
    end
  end
  { name: "0.0.1", code: 1 }
end

def get_version_string
  version = get_version()
  "#{version[:name]}+#{version[:code]}"
end

def get_version_name
  get_version()[:name]
end

def get_version_code
  get_version()[:code]
end

def get_git_branch
  branch = sh("git rev-parse --abbrev-ref HEAD", log: false).strip
  branch
rescue
  "main"
end

def load_env(env)
  # Validate environment
  valid_envs = ["dev", "uat", "prod"]
  unless valid_envs.include?(env)
    UI.user_error!("❌ Invalid environment: #{env}. Must be one of: #{valid_envs.join(', ')}")
  end

  # Load environment file from DO_NOT_SHARE folder
  env_file = File.join(Dir.pwd, "DO_NOT_SHARE", ".env.fastlane.#{env}")

  unless File.exist?(env_file)
    UI.user_error!(
      "❌ Environment file not found: #{env_file}\n" +
      "   Please create DO_NOT_SHARE/.env.fastlane.#{env} file."
    )
  end

  # Load the .env file
  Dotenv.load(env_file)

  puts "✅ Loaded environment: #{env}"
  puts "   File: DO_NOT_SHARE/.env.fastlane.#{env}"
  puts "   DEBUG: #{ENV['DEBUG']}"
end

def calculate_new_version(current_version, branch_name)
  # current_version is a hash with :name and :code
  version_name = current_version[:name]
  version_code = current_version[:code]

  # Parse current version name (major.minor.patch)
  parts = version_name.split(".").map(&:to_i)
  major = parts[0] || 0
  minor = parts[1] || 0
  patch = parts[2] || 1

  branch_lower = branch_name.downcase

  # Check branch type
  if branch_lower.include?("release")
    # Release branch: bump major version (0.0.1 -> 1.0.0)
    major += 1
    minor = 0
    patch = 0
    puts "🚀 Release branch detected - bumping major version"
  elsif branch_lower.include?("uat")
    # UAT branch: bump minor version (0.0.1 -> 0.1.0)
    minor += 1
    patch = 0
    puts "🧪 UAT branch detected - bumping minor version"
  else
    # Default/feature branch: bump patch version (0.0.1 -> 0.0.2)
    patch += 1
    puts "🔧 Feature/development branch - bumping patch version"
  end

  new_version_name = "#{major}.#{minor}.#{patch}"
  new_version_code = version_code + 1

  { name: new_version_name, code: new_version_code }
end
